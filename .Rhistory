<<<<<<< HEAD
library(dplyr)
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
library(tidyverse)
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
library(stringr)
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
DATA$Toronto %<>% as.numeric
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
head(M.Data)
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
head(M.Data)
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
head(Exclude)
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
head(M.Data)
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
head(M.Data)
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
transform_data <- function(DATA){
DATA$Toronto %<>% as.numeric
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
#.- Subset data to put in the map
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
}
Data_organized <- lmap(Data_divided, transform_data)
transform_data(Data_divided[[2]])
Stats
Data_organized <- lmap(Data_divided, transform_data)
transform_data(Data_divided[[2]])
Data_divided[[2]]
DATA$Toronto %<>% as.numeric
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
#.- Subset data to put in the map
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
transform_data(DATA)
transform_data <- function(DATA){
DATA$Toronto %<>% as.numeric
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
#.- Subset data to put in the map
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
}
transform_data(DATA)
transform_data(Data_divided[[3]])
transform_data(Data_divided[[4]])
Data_organized <- lmap(Data_divided, transform_data)
DATA
Data_divided[[4]]
data.frame(Data_divided[[4]])
transform_data <- function(DATA){
DATA$Toronto %<>% as.numeric
DATA %<>% (!is.na(Toronto))
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
#.- Subset data to put in the map
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
}
transform_data(Data_divided[[4]])
head(Data_divided[[4]])
DATA <- Data_divided[[4]]
DATA
DATA$Toronto %<>% as.numeric
DATA %<>% (!is.na(Toronto))
transform_data <- function(DATA){
DATA$Toronto %<>% as.numeric
DATA %<>% filter(!is.na(Toronto))
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
#.- Subset data to put in the map
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
}
Data_organized <- lmap(Data_divided, transform_data)
DATA$Toronto %<>% as.numeric
DATA %<>% filter(!is.na(Toronto))
DATA
transform_data(Data_divided[[4]])
transform_data(Data_divided[[5]])
transform_data(Data_divided[[6]])
transform_data <- function(DATA){
DATA %<>% filter(!is.na(Toronto))
DATA$Toronto %<>% as.numeric
#Melt the data and make Wards as rows and data as columns
M.Data <- DATA %>%
gather( Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
M.Data %<>% spread(value = value , key = Attributes)
#.- Subset data to put in the map
Exclude <- which(colnames(M.Data) %in% c("Ward", 'Total') )
M.Data[,-c(Exclude)] <-   M.Data[,-Exclude] * 100 / M.Data$Total
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
Stats <- M.Data %>% select(-Ward) %>%
filter(!is.na(SCODE_NAME))
Stats
}
transform_data(Data_divided[[6]])
transform_data(Data_divided[[7]])
transform_data(Data_divided[[8]])
transform_data(Data_divided[[9]])
Data_organized <- lmap(Data_divided, transform_data)
lmap(Data_divided,nrow)
lmap(Data_divided,ncol)
maybe_rep <- function(x) {
n <- rpois(1, 2)
out <- rep_len(x, n)
if (length(out) > 0) {
names(out) <- paste0(names(x), seq_len(n))
}
out
}
# The output size varies each time we map f()
x <- list(a = 1:4, b = letters[5:7], c = 8:9, d = letters[10])
x %>% lmap(maybe_rep)
# We can apply f() on a selected sub
x
Data_organized <- lapply(Data_divided, transform_data)
head(Data_organized)
names(Data_organized)
saveRDS(Stats, 'Map Toronto/Data_organized.RDS')
saveRDS(Data_organized, 'Map Toronto/Data_organized.RDS')
head(Map_draw)
Map_draw <- readRDS('../Map_draw.RDS')
readRDS
readRDS('Map Toronto/Map_draw.RDS')
readRDS('Map Toronto/Map_draw.RDS') %>% head
#3.-Deal with the statistical data
DATA <- read_excel('Map Toronto/Ward Profiles - Census_2011.xlsx',
range = 'A11:AX642')
#Take a look at the rows
head(DATA)
colnames(DATA)[1] <- 'Attributes'
M.Data <- gather(DATA, Ward, value, -Attributes) %>%
filter(!is.na(value), !is.na(Attributes))
M.Data$value %<>% as.numeric
#Get the code name out of the Ward variable
M.Data$SCODE_NAME <- str_extract(string = M.Data$Ward, '[0-9]+') %>%
as.numeric
head(M.Data)
Map <- readRDS('Map Toronto/Ward 2/Map.RDS')
Map$SCODE_NAME %<>% as.character  %>% as.numeric
Map@data %<>% left_join(Data_organized[[1]])
head(Map)
head(Map@data)
Map %<>% spTransform(CRS("+proj=longlat +datum=WGS84"))
Map_draw <- fortify(Map, region ='SCODE_NAME')
Map_draw$id %<>% as.numeric
Data <- Map@data
#Add the stats to the map data
Map_draw %<>% left_join( Data,
by = c('id'='SCODE_NAME'))
Map <- readRDS('Map Toronto/Ward 2/Map.RDS')
#Join
Map$SCODE_NAME %<>% as.character  %>% as.numeric
Map@data %<>% left_join(Data_organized[[1]])
#Transform polygon data into a data.frame
Map %<>% spTransform(CRS("+proj=longlat +datum=WGS84"))
Map_draw <- fortify(Map, region ='SCODE_NAME')
Map_draw$id %<>% as.numeric
Data <- Map@data
#Add the stats to the map data
Map_draw %<>% left_join( Data,
by = c('id'='SCODE_NAME'))
Toronto <- readRDS('Map Toronto/Toronto.RDS')
ditch_the_axes <- theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.title = element_blank()
)
#Plot the map
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Multiple responses`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
library(ggmpa)
library(ggmap)
Toronto <- readRDS('Map Toronto/Toronto.RDS')
ditch_the_axes <- theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.title = element_blank()
)
#Plot the map
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Multiple responses`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
#Aggregate data to get mean latitude and mean longitude for each state
cnames <- aggregate(cbind(long, lat) ~ NAME, data=Map_draw,
FUN=function(x) mean(range(x)))
cnames$New_Name <- gsub(pattern = " *\\(.*?\\) *",
x = cnames$NAME, replacement = '')
cnames$New_Name <- gsub(pattern = "-",
x = cnames$New_Name, replacement = '\n')
cnames$New_Name <- gsub(pattern = ' ',
x = cnames$New_Name, replacement = '\n')
saveRDS(cnames, 'Map Toronto/cnames.RDS')
#Download the map from goggle maps
# Toronto <- get_map(location = c(-79.43, 43.725), zoom=10)
#saveRDS(Toronto, 'Map Toronto/Toronto.RDS')
Toronto <- readRDS('Map Toronto/Toronto.RDS')
ditch_the_axes <- theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.title = element_blank()
)
#Plot the map
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Multiple responses`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Owner`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Renter`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
cnames <- readRDS('Map Toronto/cnames.RDS')
Map@data %<>% left_join(Data_organized[[2]]) #Join with what you are interested
Map %<>% spTransform(CRS("+proj=longlat +datum=WGS84"))
Map_draw <- fortify(Map, region ='SCODE_NAME')
Map_draw$id %<>% as.numeric
Data <- Map@data
Map_draw %<>% left_join( Data,
by = c('id'='SCODE_NAME'))
saveRDS(Map_draw, 'Map Toronto/Map_draw.RDS')
cnames <- readRDS('Map Toronto/cnames.RDS')
Toronto <- readRDS('Map Toronto/Toronto.RDS')
ditch_the_axes <- theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.title = element_blank()
)
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Renter`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
Map_draw %>% head
Map <- readRDS('Map Toronto/Ward 2/Map.RDS')
Map$SCODE_NAME %<>% as.character  %>% as.numeric
for(i in 1:length(Data_organized)){
Map@data %>% left_join(Data_organized[[i]])
}
Map %<>% spTransform(CRS("+proj=longlat +datum=WGS84"))
Map_draw <- fortify(Map, region ='SCODE_NAME')
Map_draw$id %<>% as.numeric
Data <- Map@data
Map_draw %<>% left_join( Data,
by = c('id'='SCODE_NAME'))
saveRDS(Map_draw, 'Map Toronto/Map_draw.RDS')
#Get cnames
cnames <- readRDS('Map Toronto/cnames.RDS')
#6.- Plot the data
#Download the map from goggle maps
# Toronto <- get_map(location = c(-79.43, 43.725), zoom=10)
#saveRDS(Toronto, 'Map Toronto/Toronto.RDS')
Toronto <- readRDS('Map Toronto/Toronto.RDS')
ditch_the_axes <- theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.title = element_blank()
)
#Plot the map
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Renter`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
head(Map_draw)
for(i in 1:length(Data_organized)){
Map@data %<>% left_join(Data_organized[[i]], by = 'SCODE_NAME')
}
head(Map@data)
dim(Map@data)
#Transform polygon data into a data.frame
Map %<>% spTransform(CRS("+proj=longlat +datum=WGS84"))
Map_draw <- fortify(Map, region ='SCODE_NAME')
Map_draw$id %<>% as.numeric
Data <- Map@data
#Add the stats to the map data
Map_draw %<>% left_join( Data,
by = c('id'='SCODE_NAME'))
saveRDS(Map_draw, 'Map Toronto/Map_draw.RDS')
#Get cnames
cnames <- readRDS('Map Toronto/cnames.RDS')
#6.- Plot the data
#Download the map from goggle maps
# Toronto <- get_map(location = c(-79.43, 43.725), zoom=10)
#saveRDS(Toronto, 'Map Toronto/Toronto.RDS')
Toronto <- readRDS('Map Toronto/Toronto.RDS')
ditch_the_axes <- theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
panel.border = element_blank(),
panel.grid = element_blank(),
axis.title = element_blank()
)
#Plot the map
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Renter`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Owner`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `Owner`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
colnames(Map_draw)
ggmap(Toronto, extent = 'normal') +
geom_polygon(data = Map_draw,
aes(long, lat, group = group,fill = `$100,000 and over`),
colour = 'gray', alpha =.7) +
geom_text(data =cnames, aes(long, lat, label = New_Name),
size =3, check_overlap = TRUE) +
coord_map() +
scale_fill_gradient(low = 'white', high = 'dark blue') +
xlim(c(-79.65,-79.10)) + ylim(c(43.55,43.88)) +
labs(fill=' ') +
ditch_the_axes
shiny::runApp('Map Toronto/Toronto_languages')
runApp('Map Toronto/Toronto_languages')
setwd("~/XPLORER/")
source("~/XPLORER/INDICADORES/src/0_READ_HISTORICAL_PRICES.R")
cat("Checking for new stocks in the portfolio \n \n")
#source("~/XPLORER/INDICADORES/src/1_UPDATE_STOCKS.R")
source("~/XPLORER/INDICADORES/src/1_UPDATE_STOCKS_google.R")
cat("Creating the report \n \n")
source("~/XPLORER/INDICADORES/src/2_Stock_process.R")
cat("\n \n \n ============================== \n")
cat("       Report ready \n")
cat(" ============================== \n \n")
Sys.sleep(3)
# Update the stock report
setwd("~/XPLORER/")
source("~/XPLORER/INDICADORES/src/0_READ_HISTORICAL_PRICES.R")
cat("Checking for new stocks in the portfolio \n \n")
#source("~/XPLORER/INDICADORES/src/1_UPDATE_STOCKS.R")
source("~/XPLORER/INDICADORES/src/1_UPDATE_STOCKS_google.R")
cat("Creating the report \n \n")
source("~/XPLORER/INDICADORES/src/2_Stock_process.R")
cat("\n \n \n ============================== \n")
cat("       Report ready \n")
cat(" ============================== \n \n")
Sys.sleep(3)
=======
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date, y = PC1, color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_line() +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#Box plot by teams
ggplot(data= STATS, aes(y = PC1, x = reorder(Team, PC1, FUN = median),  color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_boxplot(show.legend = F) +
facet_wrap(~League, scales = 'free_y') + coord_flip() +
scale_color_manual(values=cbPalette)
#Index of the best teams from 2011 to 2016 with more than 40 matches in the DB
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
# Missing to add a moving average so the index can determine the "current INdex'
# of each Team
STATS %<>% group_by(Team) %>%  filter(n()>30) %>%
arrange(Date) %>%
mutate(
M.A.PC1 = rollmeanr(PC1, 15, fill = NA ),
M.A.PC2 = rollmeanr(PC2, 15, fill = NA )
)
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date )) +
geom_hline(yintercept= 0, colour ='red', size = .1) +
geom_line(aes(y = PC1), colour = 'gray', linetype= 2) +
geom_line(aes(y = M.A.PC1, color = League)) +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#How good does the index explains the result??
#Average according to the scores
AVG_PC1 <- STATS %>% group_by(Dif = Goals - Goals_Opp) %>%
summarise(
PC1.mean = mean(PC1),
count = n()
)
ggplot(STATS, aes(y = PC1, group = Goals - Goals_Opp, x = Goals - Goals_Opp)) +
geom_boxplot()
ggplot(data = STATS, aes(y = PC2, x = PC1)) +
geom_point(aes(color = Goals - Goals_Opp))  +
scale_colour_gradient(low = 'white', high = 'red')
ggplot(data = STATS, aes(y = Goals, x =  PC1)) +
geom_jitter() +
geom_smooth()
lm(formula =   Goals - Goals_Opp~PC1, data= STATS) %>% summary
#No explica mucho
#Using Moving average get the latest MA of each team and plot it
Index.2016 <- STATS %>% group_by(Team) %>%
filter(Date == max(Date)) %>%
select(Team, M.A.PC1, M.A.PC2, Date, League) %>% filter(Date>= as.Date('2016-11-01'))
ggplot(Index.2016, aes(x = M.A.PC1, y = M.A.PC2, color = League)) +
geom_point(show.legend = F) +
geom_text(aes(label = Team), check_overlap = TRUE, nudge_y = 0.08,
show.legend = F)
Fouls.cols <- grep('Faltas|Tarjetas',colnames(STATS), value = T)
#Why one league is divided by PC.2
Fouls.summary <- STATS %>% ddply(.(League), function(x){
sapply(x[,Fouls.cols], mean)
})
#Standarize  all variables related with fouls
STATS %<>% group_by(League) %>%
mutate_each(funs(scale ), contains("Faltas"), contains('Tarje'))
STATS %<>% sapply(as.vector)
STATS %<>% select(-contains("PC"))
Princomp <- princomp(STATS[,-c(1:4)])
head(STATS)
#=============================================================================
cbPalette <- c( "#E69F00", "#56B4E9", "#009E73", "#F0E442",
"#0072B2", "#D55E00", "#CC79A7")
library(magrittr)
library(stringr)
library(tidyverse)
library(ggplot2)
require(forecast)
options(stringsAsFactors = F)
theme_set(theme_minimal())
STATS <- read.csv('Index_performance/DATABASE.csv')
STATS[,-c(1:4)] %<>% sapply(as.numeric)
STATS$Date %<>%  as.Date
STATS %<>% filter(variable == 'Home')
#Principal components
Princomp <- princomp(STATS[,-c(1:4)], cor = T)
#Find number of components that explain most of the data
plot(Princomp)
#Biplot
biplot(Princomp)
#Loadings
(Loadings <- Princomp$loadings[,1:2] %>% round(2) %>% data.frame %>%
mutate(Attribute = rownames(.)) %>%
select(Attribute, everything()) %>%
arrange(Comp.1))
#Scores 2 component add it to DATA
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date, y = PC1, color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_line() +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#Box plot by teams
ggplot(data= STATS, aes(y = PC1, x = reorder(Team, PC1, FUN = median),  color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_boxplot(show.legend = F) +
facet_wrap(~League, scales = 'free_y') + coord_flip() +
scale_color_manual(values=cbPalette)
#Index of the best teams from 2011 to 2016 with more than 40 matches in the DB
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
# Missing to add a moving average so the index can determine the "current INdex'
# of each Team
STATS %<>% group_by(Team) %>%  filter(n()>30) %>%
arrange(Date) %>%
mutate(
M.A.PC1 = rollmeanr(PC1, 15, fill = NA ),
M.A.PC2 = rollmeanr(PC2, 15, fill = NA )
)
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date )) +
geom_hline(yintercept= 0, colour ='red', size = .1) +
geom_line(aes(y = PC1), colour = 'gray', linetype= 2) +
geom_line(aes(y = M.A.PC1, color = League)) +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#How good does the index explains the result??
#Average according to the scores
AVG_PC1 <- STATS %>% group_by(Dif = Goals - Goals_Opp) %>%
summarise(
PC1.mean = mean(PC1),
count = n()
)
ggplot(STATS, aes(y = PC1, group = Goals - Goals_Opp, x = Goals - Goals_Opp)) +
geom_boxplot()
ggplot(data = STATS, aes(y = PC2, x = PC1)) +
geom_point(aes(color = Goals - Goals_Opp))  +
scale_colour_gradient(low = 'white', high = 'red')
ggplot(data = STATS, aes(y = Goals, x =  PC1)) +
geom_jitter() +
geom_smooth()
lm(formula =   Goals - Goals_Opp~PC1, data= STATS) %>% summary
#No explica mucho
#Using Moving average get the latest MA of each team and plot it
Index.2016 <- STATS %>% group_by(Team) %>%
filter(Date == max(Date)) %>%
select(Team, M.A.PC1, M.A.PC2, Date, League) %>% filter(Date>= as.Date('2016-11-01'))
ggplot(Index.2016, aes(x = M.A.PC1, y = M.A.PC2, color = League)) +
geom_point(show.legend = F) +
geom_text(aes(label = Team), check_overlap = TRUE, nudge_y = 0.08,
show.legend = F)
Fouls.cols <- grep('Faltas|Tarjetas',colnames(STATS), value = T)
#Why one league is divided by PC.2
Fouls.summary <- STATS %>% ddply(.(League), function(x){
sapply(x[,Fouls.cols], mean)
})
#Standarize  all variables related with fouls
STATS %<>% group_by(League) %>%
mutate_each(funs(scale ), contains("Faltas"), contains('Tarje'))
STATS %<>% sapply(as.numeric)
STATS %<>% select(-contains("PC"))
#Principal components
Princomp <- princomp(STATS[,-c(1:4)])
#Find number of components that explain most of the data
plot(Princomp)
#Biplot
biplot(Princomp)
#Rerun the princomp
(Loadings <- Princomp$loadings[,1:2] %>% round(2) %>% data.frame %>%
mutate(Attribute = rownames(.)) %>%
select(Attribute, everything()) %>%
arrange(Comp.1))
#Scores 2 component add it to DATA
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
Princomp <- princomp(STATS[,-c(1:4)], cor = T)
head(STATS)
?scales
?scale
STATS <- read.csv('Index_performance/DATABASE.csv')
STATS$Goals %>% scale
STATS$Goals %>% scale %>% data.frame
STATS$Goals %>% scale %>% data.frame %>% head
scale.data.frame <- function(x){
scale(x) %>% data.frame
}
#=============================================================================
#                   Create an index according to performance
#=============================================================================
cbPalette <- c( "#E69F00", "#56B4E9", "#009E73", "#F0E442",
"#0072B2", "#D55E00", "#CC79A7")
library(magrittr)
library(stringr)
library(tidyverse)
library(ggplot2)
require(forecast)
options(stringsAsFactors = F)
theme_set(theme_minimal())
STATS <- read.csv('Index_performance/DATABASE.csv')
STATS[,-c(1:4)] %<>% sapply(as.numeric)
STATS$Date %<>%  as.Date
STATS %<>% filter(variable == 'Home')
#Principal components
Princomp <- princomp(STATS[,-c(1:4)], cor = T)
#Find number of components that explain most of the data
plot(Princomp)
#Biplot
biplot(Princomp)
#Loadings
(Loadings <- Princomp$loadings[,1:2] %>% round(2) %>% data.frame %>%
mutate(Attribute = rownames(.)) %>%
select(Attribute, everything()) %>%
arrange(Comp.1))
#Scores 2 component add it to DATA
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date, y = PC1, color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_line() +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#Box plot by teams
ggplot(data= STATS, aes(y = PC1, x = reorder(Team, PC1, FUN = median),  color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_boxplot(show.legend = F) +
facet_wrap(~League, scales = 'free_y') + coord_flip() +
scale_color_manual(values=cbPalette)
#Index of the best teams from 2011 to 2016 with more than 40 matches in the DB
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
# Missing to add a moving average so the index can determine the "current INdex'
# of each Team
STATS %<>% group_by(Team) %>%  filter(n()>30) %>%
arrange(Date) %>%
mutate(
M.A.PC1 = rollmeanr(PC1, 15, fill = NA ),
M.A.PC2 = rollmeanr(PC2, 15, fill = NA )
)
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date )) +
geom_hline(yintercept= 0, colour ='red', size = .1) +
geom_line(aes(y = PC1), colour = 'gray', linetype= 2) +
geom_line(aes(y = M.A.PC1, color = League)) +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#How good does the index explains the result??
#Average according to the scores
AVG_PC1 <- STATS %>% group_by(Dif = Goals - Goals_Opp) %>%
summarise(
PC1.mean = mean(PC1),
count = n()
)
ggplot(STATS, aes(y = PC1, group = Goals - Goals_Opp, x = Goals - Goals_Opp)) +
geom_boxplot()
ggplot(data = STATS, aes(y = PC2, x = PC1)) +
geom_point(aes(color = Goals - Goals_Opp))  +
scale_colour_gradient(low = 'white', high = 'red')
ggplot(data = STATS, aes(y = Goals, x =  PC1)) +
geom_jitter() +
geom_smooth()
lm(formula =   Goals - Goals_Opp~PC1, data= STATS) %>% summary
#No explica mucho
#Using Moving average get the latest MA of each team and plot it
Index.2016 <- STATS %>% group_by(Team) %>%
filter(Date == max(Date)) %>%
select(Team, M.A.PC1, M.A.PC2, Date, League) %>% filter(Date>= as.Date('2016-11-01'))
ggplot(Index.2016, aes(x = M.A.PC1, y = M.A.PC2, color = League)) +
geom_point(show.legend = F) +
geom_text(aes(label = Team), check_overlap = TRUE, nudge_y = 0.08,
show.legend = F)
Fouls.cols <- grep('Faltas|Tarjetas',colnames(STATS), value = T)
#Why one league is divided by PC.2
Fouls.summary <- STATS %>% ddply(.(League), function(x){
sapply(x[,Fouls.cols], mean)
})
#Tweak scale function
scale.data.frame <- function(x){
scale(x) %>% data.frame
}
#Standarize  all variables related with fouls
STATS %<>% group_by(League) %>%
mutate_each(funs(scale.data.frame), contains("Faltas"), contains('Tarje'))
#=============================================================================
#                   Create an index according to performance
#=============================================================================
cbPalette <- c( "#E69F00", "#56B4E9", "#009E73", "#F0E442",
"#0072B2", "#D55E00", "#CC79A7")
library(magrittr)
library(stringr)
library(tidyverse)
library(ggplot2)
require(forecast)
options(stringsAsFactors = F)
theme_set(theme_minimal())
STATS <- read.csv('Index_performance/DATABASE.csv')
STATS[,-c(1:4)] %<>% sapply(as.numeric)
STATS$Date %<>%  as.Date
STATS %<>% filter(variable == 'Home')
#Principal components
Princomp <- princomp(STATS[,-c(1:4)], cor = T)
#Find number of components that explain most of the data
plot(Princomp)
#Biplot
biplot(Princomp)
#Loadings
(Loadings <- Princomp$loadings[,1:2] %>% round(2) %>% data.frame %>%
mutate(Attribute = rownames(.)) %>%
select(Attribute, everything()) %>%
arrange(Comp.1))
#Scores 2 component add it to DATA
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date, y = PC1, color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_line() +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#Box plot by teams
ggplot(data= STATS, aes(y = PC1, x = reorder(Team, PC1, FUN = median),  color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_boxplot(show.legend = F) +
facet_wrap(~League, scales = 'free_y') + coord_flip() +
scale_color_manual(values=cbPalette)
#Index of the best teams from 2011 to 2016 with more than 40 matches in the DB
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
# Missing to add a moving average so the index can determine the "current INdex'
# of each Team
STATS %<>% group_by(Team) %>%  filter(n()>30) %>%
arrange(Date) %>%
mutate(
M.A.PC1 = rollmeanr(PC1, 15, fill = NA ),
M.A.PC2 = rollmeanr(PC2, 15, fill = NA )
)
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date )) +
geom_hline(yintercept= 0, colour ='red', size = .1) +
geom_line(aes(y = PC1), colour = 'gray', linetype= 2) +
geom_line(aes(y = M.A.PC1, color = League)) +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#How good does the index explains the result??
#Average according to the scores
AVG_PC1 <- STATS %>% group_by(Dif = Goals - Goals_Opp) %>%
summarise(
PC1.mean = mean(PC1),
count = n()
)
ggplot(STATS, aes(y = PC1, group = Goals - Goals_Opp, x = Goals - Goals_Opp)) +
geom_boxplot()
ggplot(data = STATS, aes(y = PC2, x = PC1)) +
geom_point(aes(color = Goals - Goals_Opp))  +
scale_colour_gradient(low = 'white', high = 'red')
ggplot(data = STATS, aes(y = Goals, x =  PC1)) +
geom_jitter() +
geom_smooth()
lm(formula =   Goals - Goals_Opp~PC1, data= STATS) %>% summary
#No explica mucho
#Using Moving average get the latest MA of each team and plot it
Index.2016 <- STATS %>% group_by(Team) %>%
filter(Date == max(Date)) %>%
select(Team, M.A.PC1, M.A.PC2, Date, League) %>% filter(Date>= as.Date('2016-11-01'))
ggplot(Index.2016, aes(x = M.A.PC1, y = M.A.PC2, color = League)) +
geom_point(show.legend = F) +
geom_text(aes(label = Team), check_overlap = TRUE, nudge_y = 0.08,
show.legend = F)
Fouls.cols <- grep('Faltas|Tarjetas',colnames(STATS), value = T)
#Why one league is divided by PC.2
Fouls.summary <- STATS %>% ddply(.(League), function(x){
sapply(x[,Fouls.cols], mean)
})
#Tweak scale function
scale.data.frame <- function(x){
scale(x) %>% data.frame
}
#Standarize  all variables related with fouls
SS <- STATS %>% group_by(League) %>%
mutate_each(funs(scale.data.frame), contains("Faltas"), contains('Tarje'))
#=============================================================================
#                   Standarize fouls vars by league
#=============================================================================
cbPalette <- c( "#E69F00", "#56B4E9", "#009E73", "#F0E442",
"#0072B2", "#D55E00", "#CC79A7")
library(magrittr)
library(stringr)
library(tidyverse)
library(ggplot2)
require(forecast)
options(stringsAsFactors = F)
theme_set(theme_minimal())
STATS <- read.csv('Index_performance/DATABASE.csv')
STATS[,-c(1:4)] %<>% sapply(as.numeric)
STATS$Date %<>%  as.Date
STATS %<>% filter(variable == 'Home')
Fouls.cols <- grep('Faltas|Tarjetas',colnames(STATS), value = T)
#Why one league is divided by PC.2
Fouls.summary <- STATS %>% ddply(.(League), function(x){
sapply(x[,Fouls.cols], mean)
})
#Tweak scale function
scale.data.frame <- function(x){
scale(x) %>% data.frame
}
SS <- STATS %>% group_by(League) %>%
mutate_each(funs(scale.data.frame), contains("Faltas"), contains('Tarje'))
scale(x) %>% c
scale.data.frame <- function(x){
scale(x) %>% c
}
SS <- STATS %>% group_by(League) %>%
mutate_each(funs(scale.data.frame), contains("Faltas"), contains('Tarje'))
head(SS)
sapply(SS,class())
sapply(SS,class)
STATS %<>% group_by(League) %>%
mutate_each(funs(scale.data.frame), contains("Faltas"), contains('Tarje'))
Princomp <- princomp(STATS[,-c(1:4)], cor = T)
plot(Princomp)
biplot(Princomp)
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
head(STATS)
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
#=============================================================================
#                   Create an index according to performance
#=============================================================================
cbPalette <- c( "#E69F00", "#56B4E9", "#009E73", "#F0E442",
"#0072B2", "#D55E00", "#CC79A7")
library(magrittr)
library(stringr)
library(tidyverse)
library(ggplot2)
require(forecast)
options(stringsAsFactors = F)
theme_set(theme_minimal())
STATS <- read.csv('Index_performance/DATABASE.csv')
STATS[,-c(1:4)] %<>% sapply(as.numeric)
STATS$Date %<>%  as.Date
STATS %<>% filter(variable == 'Home')
#Principal components
Princomp <- princomp(STATS[,-c(1:4)], cor = T)
#Find number of components that explain most of the data
plot(Princomp)
#Biplot
biplot(Princomp)
#Loadings
(Loadings <- Princomp$loadings[,1:2] %>% round(2) %>% data.frame %>%
mutate(Attribute = rownames(.)) %>%
select(Attribute, everything()) %>%
arrange(Comp.1))
#Scores 2 component add it to DATA
STATS$PC1<- Princomp$scores[,1]
STATS$PC2<- Princomp$scores[,2]
#Plot time series of the Index by teams
ggplot(data= STATS, aes(x= Date, y = PC1, color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_line() +
facet_wrap(~Team) +
scale_color_manual(values=cbPalette)
#Box plot by teams
ggplot(data= STATS, aes(y = PC1, x = reorder(Team, PC1, FUN = median),  color = League)) +
geom_hline(yintercept= 0, colour ='red') +
geom_boxplot(show.legend = F) +
facet_wrap(~League, scales = 'free_y') + coord_flip() +
scale_color_manual(values=cbPalette)
#Index of the best teams from 2011 to 2016 with more than 40 matches in the DB
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise_each(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
library(dplyr)
STATS  %>%
group_by(Team) %>% filter(n()>30) %>%   summarise(
Index.1 = mean(PC1),
Index.2 = mean(PC2)
) %>% arrange(desc(Index.2)) %>% data.frame
reload.project()
>>>>>>> origin/master
